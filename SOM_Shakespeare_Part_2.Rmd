---
title: "Self Organizing Maps and Text Mining - Shakespeare SOMs (Part 2)"
author: Daniel Tanner
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
   toc: True
   toc_depth: 2
   toc_float: True
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE, fig.align='center', message = FALSE, warning = FALSE)
```

#Character SOM

The zipped folder we downloaded in the previous example also contains a document for each character in each play containing all of that character's lines. In this next example we'll make a SOM to see if we can find relationships between characters based on their vocabularies.

I've already built a `character_table`, similar to the `play_table` used in the last example. [You can see how this was constructed here](https://clarkdatalabs.github.io/soms/Build_Tables). 

```{r, cache=TRUE}
library("RCurl")
character_table <- read.csv(text=getURL("https://raw.githubusercontent.com/clarkdatalabs/soms/master/Shakespeare_tables/character_table.csv"), sep=",", header=T, check.names = TRUE, stringsAsFactors = FALSE)
```

Let's look at the metadata we have for each text file of lines:

```{r}
head(character_table[,c("char", "play", "genre")], 10)
```

Note the [*Dramatis_personae*](https://en.wikipedia.org/wiki/Dramatis_person%C3%A6) character. Each play has one of these documents, which is just a list of characters and contains no lines. Let's get rid of them.

```{r}
#character_table <- subset(character_table, char!="Dramatis_personae")
```

##Form Corpus
```{r}
library("tm")
character.corpus <- Corpus(VectorSource(character_table[,"text"]))
```

##Clean Character Text

The text here has the same bracketed tags, white space, punctuation, and uncommon words that we stripped out of the play text above, so we follow the same procedure to simplify it. This time we'll use the special `tm_reduce` option of the `tm_map` function, which allows us to combine all of our text simplifications into one step.

_Note: this may take a few minutes to run._
```{r clean character text, tidy=FALSE, cache=TRUE}
library("SnowballC")

striptags <- function(x) gsub(x, pattern = '<[^>]*>', replacement = '')
skipwords <- function(x) removeWords(x, stopwords("english"))

funcs <- list(content_transformer(striptags),
              removePunctuation, 
              removeNumbers, 
              content_transformer(tolower), 
              skipwords, 
              stemDocument, 
              stripWhitespace, 
              removePunctuation)

character.corpus <- tm_map(character.corpus, FUN = tm_reduce, tmFuns = funcs)
```

Form Document Term Matrix:
```{r}
character.DTM <- DocumentTermMatrix(character.corpus)
```

Remove Sparse Terms
```{r}
character.DTM.modified <- removeSparseTerms(character.DTM, 0.90)
```


Let's see what this did to the wordcounts for some of our characters.
```{r, tidy=FALSE}
wordcount.DTM <- rowSums(as.matrix(character.DTM))
wordcount.DTM.modified <- rowSums(as.matrix(character.DTM.modified))

head(cbind(character_table$char,
           "DTM" = wordcount.DTM,
           "DTM.modified" = wordcount.DTM.modified), 10)
```
```{r, tidy=FALSE}
test <- cbind(character_table$char,
           "DTM" = wordcount.DTM,
           "DTM.modified" = wordcount.DTM.modified)
```


Overall this seems to have cut a fair number of words out of each character's wordcount. Also note that there are some characters don't have many lines at all. Let's exclude characters that have fewer than 200 filtered words.

```{r}
character.DTM.modified <- character.DTM.modified[wordcount.DTM.modified>200, ]
```

##Normalize & TF-IDF

```{r}
character.DTM.modified <- weightTfIdf(character.DTM.modified, normalize = TRUE)
```

##Merge with metadata
```{r}
character.DTM_df <- data.frame(as.matrix(character.DTM.modified))
character.DTM_df <- merge(character_table[,c("char", "play", "genre")], character.DTM_df, by.x = "row.names", by.y = "row.names", suffixes = c("", ".DTM"))
```


##PLOT!
First we make our SOM
```{r}

library(kohonen)
character.SOM <- som(as.matrix(character.DTM_df[,!names(character.DTM_df) %in% c("Row.names","char","play","genre")]), 
                     grid = somgrid(10, 10, "hexagonal"), 
                     toroidal = TRUE)
```

Make label matrix
```{r, tidy=FALSE}
characters.to.plot <- c("Romeo", 
                        "Juliet",
                        "K. Henry",
                        "Macbeth",
                        "Hermia",
                        "Othello",
                        "Puck",
                        "Borachio")

character.labels <- c()

X <- character.DTM_df[,"char"]
for (i in 1:length(X)) {
    if (X[i] %in% characters.to.plot) {
        character.labels[i] <- X[i]
    } else {
        character.labels[i] <- "+"
    }
}
remove(i,X)
```


#Plot characters

set palette
```{r}
#palette.3 <- palette(rainbow(3, s=1, v = .9, start = 0))
#palette.3 <- c("darkred","darkorchid4", "royalblue4")
palette.3 <- c("firebrick1","darkolivegreen3", "dodgerblue2")
```

Dim all of the labels that we don't want to display the full name for.
```{r}

dim.symbols <- function(x){
  if (nchar(x)<2) {return(0.5)}
  else {return(1)}
}

genre.label.data <- 
  cbind(char = character.DTM_df$char,
        label = character.labels, 
        base_color = palette.3[as.factor(character.DTM_df$genre)],
        transparency = lapply(character.labels,dim.symbols))

genre.label.data <- as.data.frame(genre.label.data)

label.colors <- c()
for (row in 1:nrow(genre.label.data)){
  label.colors[row] <- adjustcolor(genre.label.data[row,"base_color"], alpha.f = genre.label.data[row,"transparency"])
}

genre.label.data <- cbind(genre.label.data, label_color = label.colors)
remove(row, label.colors)
```

Code Distances function from part 1:
```{r}
code.distances <- function(SOM){
  N <- nrow(SOM$codes)
  #calculate all pairwise distances
  pairwise.distances = c()
  for (i in 1:N){
    list <- matrix()
    for (j in 1:N){
      list[j] <- dist(rbind(SOM$codes[i,],SOM$codes[j,]))
    }
    pairwise.distances <- cbind(pairwise.distances, list)
  }
  
  ##distance coefficient function, to be applied to geometric GRID distances
  d.coef<-function(x){
    if (x == 0){return(0)}
    else{return(1/(x^4))}
    }
  distance.coefficients <- apply(kohonen::unit.distances(SOM$grid, SOM$toroidal),c(1,2),d.coef)
  
  #calculate scaled sum of distances
  A<-distance.coefficients*pairwise.distances
  scaled.dist.sums <- (colSums(A)-min(colSums(A)))/(max(colSums(A)) - min(colSums(A)))
  
  #clean up variables
  remove(i,j)
  
  return(scaled.dist.sums)
}
```
The output of this function is a value between 0 and 1 for each cell on our SOM. Higher values represent greater overall distance from a cell to nearby cells.


##color by genre
```{r, tidy=FALSE}
par(bg = hsv(h=0,s=0,v=.7), font = 1, cex = 1.2)
plot(character.SOM, 
     type = "mapping",
     col = as.character(genre.label.data$label_color),
     bgcol = hsv(h=0.8,s=.3,v=(.5*(0.3+code.distances(character.SOM)))),
     labels = genre.label.data$label,
     main = "Shakespearean Characters")
```

There are some apparent clusters. Recall that we are using a toroidal SOM for this example, so the left and right edges and the top and bottom edges are identified. As in [part 1](https://clarkdatalabs.github.io/soms/SOM_Shakespeare_Part_1), background color signifies a cell's distance from neighboring cells. Dark cells are much closer to their neighbors than lighter colored cells. 

Even to a Shakespearean neophyte such as myself, using this SOM to do some exploration reveals a couple interesting features. Romeo and Juliet are very close to each other linguistically, as we might have expected. King Henry, on the other hand, is pretty dissimilar from himself across the multiple plays in which he is a character. 
