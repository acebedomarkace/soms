---
title: "Shakespeare SOMs"
author: Daniel Tanner
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
   toc: True
   toc_depth: 2
   toc_float: True
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE, fig.align='center', message = FALSE, warning = FALSE)
```

#Downloading Shakespeare Text
The following downloads a zipped folder containing all of the text of 37 of Shakespeare's plays (originally [available at lexically.net](http://lexically.net/wordsmith/support/shakespeare.html)).

```{r}
td <- tempdir() 
tf <- tempfile(tmpdir=td)
#download.file("http://lexically.net/downloads/corpus_linguistics/ShakespearePlaysPlus.zip", tf)

download.file("https://github.com/clarkdatalabs/soms/raw/master/ShakespearePlaysPlus.zip", tf)

#https://github.com/clarkdatalabs/soms/blob/master/ShakespearePlaysPlus.zip?raw=true


fname <- unzip(tf, list=TRUE)$Name[1] 
unzip(tf, exdir=td, overwrite=TRUE) 
fpath <- file.path(td, fname)
remove(fname)
unlink(tf)
```

The next level of subdirectory is the play genre.
```{r}
genres <- list.dirs(fpath, full.names = FALSE, recursive = FALSE)
```

We want to read in all of the play text while saving play names and genres as metadata.

```{r}
library("readr")
play_table <- data.frame(play=character(),
                         genre=character(),
                         text=character())

for (genre in genres){
  plays <- list.files(file.path(fpath,genre), pattern = ".txt")
  for (play in plays){
    play.text <- read_file(file.path(fpath,genre,play), locale(encoding = "UTF-16"))
    play.name <- gsub('.txt','', play)
    play_table <- rbind(play_table, data.frame(play = play.name, genre = genre, text = play.text))
  }
}
remove(genre, plays, play, play.name, play.text)
```

##Clean up Workspace
```{r}
unlink(td, recursive = FALSE)
```

#Forming & Cleaning a Corpus

tags
```{r}
play_table$text <- gsub('<[^>]*>','', play_table$text)
```

Form into corpus:
```{r form corpus}
library("tm")

play.vec <- VectorSource(play_table[,"text"])
play.corpus <- Corpus(play.vec)
```

Next we want to really clean up our texts. The tm package has functions for stripping punctuation, numbers, whitespace, the most common words (we don't want to be comparing counts of "and" and "to"), and converting everything to lowercase. We'll also use a function from the `SnowballC` package to cut words down to common stems for comparison.

_Note: this may take a few minutes to run._
```{r clean corpus 1}
library("SnowballC")

play.corpus <- tm_map(play.corpus, removePunctuation)
play.corpus <- tm_map(play.corpus, removeNumbers)
play.corpus <- tm_map(play.corpus, content_transformer(tolower))
play.corpus <- tm_map(play.corpus, removeWords, stopwords("english"))
play.corpus <- tm_map(play.corpus, stemDocument)
play.corpus <- tm_map(play.corpus, stripWhitespace)
play.corpus <- tm_map(play.corpus, removePunctuation)
```

Let's check out what some of the cleaned text looks like:
```{r inspect cleaned text}
substr(inspect(play.corpus[10]),1,500)
```

The functions that rely on english dictionaries had a bit of trouble with the Shakespearean English, but they're close enough.

##Document Term Matrix
Add in metadata for plotting

```{r make document term matrix}
play.DTM <- DocumentTermMatrix(play.corpus)
```

##Restrict to common words
so matrix not super sparse

```{r}
play.DTM.modified <- removeSparseTerms(play.DTM, 0.8)
```


##Normalize rows to unit length
- make each a length 1 vector
- this makes length of play not impact the SOM
-add attributes for plotting
```{r}
play.DTM.modified <- t(apply(play.DTM.modified, 1, function(x) x / sqrt(sum(x^2)) ))
attr(play.DTM.modified, "play") <- play_table$play
attr(play.DTM.modified, "genre") <- play_table$genre

```



#SOM!

```{r}
library(kohonen)

play.SOM <- som(scale(play.DTM.modified), grid = somgrid(6,6, "hexagonal"),  toroidal = FALSE)
plot(play.SOM)
```

```{r}
plot(play.SOM, type = "mapping", col = palette(rainbow(3,v=.9))[as.integer(attr(play.DTM.modified, "genre"))], bgcol = "lightgray", labels = attr(play.DTM.modified, "play"))
```


This is not a particularly clean or useful visualization. There are two main problems that we will address below.
* There are too many labeled points, which become illegible.
* The gray backgrounds of teh cells don't communicate anything. It would be nice if they could be used to convey distance of a cell to it's negihbors, like in the `dist.neighbours` type SOMs.

First, we'll just make a list of the plays we want labeled, and represent the rest with *x*.

```{r}
plays.to.plot <- c("Romeo And Juliet", "Julius Caesar", "King Lear", "Macbeth", "Othello, the Moor of Venice", "The Tragedy of King Richard II", "The Tragedy of King Richard III", "The Tempest", "The Taming of the Shrew")
play.labels <- c()
X <- as.vector(attr(play.DTM.modified, "play"))
for (i in 1:37){
  if (X[i] %in% plays.to.plot){play.labels[i] <- X[i]}
  else{play.labels[i]<-"x"}
}
```

Next, we want to essentially combine two types of kohonen SOM functions, `mapping` and `dist.neighbours`. TO do this we will write our own function to calculate the distance of a cell's representative vector to all others, strongly weighing the neighboring cells. We'll then use this do set the background color using the `mapping` type SOM.

```{r}
code.distances <- function(SOM){
  N <- nrow(SOM$codes)
  #calculate all pairwise distances
  pairwise.distances = c()
  for (i in 1:N){
    list <- matrix()
    for (j in 1:N){
      list[j] <- dist(rbind(SOM$codes[i,],SOM$codes[j,]))
    }
    pairwise.distances <- cbind(pairwise.distances, list)
  }
  
  ##distance coefficient function, to be applied to geometric GRID distances
  d.coef<-function(x){
    if (x == 0){return(0)}
    else{return(1/(x^4))}
    }
  distance.coefficients <- apply(kohonen::unit.distances(SOM$grid, SOM$toroidal),c(1,2),d.coef)
  
  #calculate scaled sum of distances
  A<-distance.coefficients*pairwise.distances
  scaled.dist.sums <- (colSums(A)-min(colSums(A)))/(max(colSums(A)) - min(colSums(A)))
  
  #clean up variables
  remove(i,j)
  
  return(scaled.dist.sums)
}
```
The output of this function is a value between 0 and 1 for each cell on our SOM. Higher values represent greater overall distance from a cell to nearby cells.


Putting it all together:

```{r}
plot(play.SOM, type = "mapping", col = palette(rainbow(3,v=.9))[as.integer(attr(play.DTM.modified, "genre"))], bgcol = hsv(h=0,s=0,v=code.distances(play.SOM)), labels = play.labels)
```


#Character SOM

The zipped folder we downloaded in the previous example also contains a document for each character in each play containing all of that character's lines. In this next example we'll make a SOM to see if we cna find relationships between characters based on their vocabularies.

I've already built a `character_table`, similar to the `play_table` used in the last example. You can see how this was constructed here. 

**INSERT LINK TO GH-PAGE!!!!!!!!!!!!**

```{r}
library("RCurl")
character_table <- read.csv(text=getURL("https://raw.githubusercontent.com/clarkdatalabs/soms/master/Shakespeare_txt/character_table.csv"), sep=",", header=T, check.names = TRUE, stringsAsFactors = FALSE)
```

Let's look at the metadata we have for each text file of lines:

```{r}
head(character_table[,c("char", "play", "genre")], 10)
```

Note the [*Dramatis_personae*](https://en.wikipedia.org/wiki/Dramatis_person%C3%A6) character. Each play has one of these documents, which is just a list of characters and contains no lines. Let's get rid of them.

```{r}
#character_table <- subset(character_table, char!="Dramatis_personae")
```

##Form Corpus
```{r}
library("tm")
character.corpus <- Corpus(VectorSource(character_table[,"text"]))
```

##Clean Character Text

The text here has the same bracketed tags, white space, punctuation, and uncommon words that we stripped out of the play text above, so we follow the same procedure to simplify it. This time we'll use the special `tm_reduce` option of the `tm_map` function, which allows us to combine all of our text simplifications into one step.

_Note: this may take a few minutes to run._
```{r}
library("SnowballC")

striptags <- function(x) gsub(x, pattern = '<[^>]*>', replacement = '')
skipwords <- function(x) removeWords(x, stopwords("english"))

funcs <- list(content_transformer(striptags),
              removePunctuation, 
              removeNumbers, 
              content_transformer(tolower), 
              skipwords, 
              stemDocument, 
              stripWhitespace, 
              removePunctuation)

character.corpus <- tm_map(character.corpus, FUN = tm_reduce, tmFuns = funcs)
```

Form Document Term Matrix:
```{r}
character.DTM <- DocumentTermMatrix(character.corpus)
```

Remove Sparse Terms
```{r}
character.DTM.modified <- removeSparseTerms(character.DTM, 0.90)
```


Let's see what this did to the wordcounts for some of our characters.
```{r}
wordcount.DTM <- rowSums(as.matrix(character.DTM))
wordcount.DTM.modified <- rowSums(as.matrix(character.DTM.modified))

head(cbind(character_table$char,
           "DTM" = wordcount.DTM,
           "DTM.modified" = wordcount.DTM.modified), 10)
```
```{r}
test <- cbind(character_table$char,
           "DTM" = wordcount.DTM,
           "DTM.modified" = wordcount.DTM.modified)
```


Overall this seems to have cut a fair number of words out of each character's wordcount. Also note that there are some characters don't have many lines at all. Let's exclude characters that have fewer than 200 filtered words.

```{r}
character.DTM.modified <- character.DTM.modified[wordcount.DTM.modified>200, ]
```

##Normalize & TF-IDF

```{r}
character.DTM.modified <- weightTfIdf(character.DTM.modified, normalize = TRUE)
```

##Merge with metadata
```{r}
character.DTM_df <- data.frame(as.matrix(character.DTM.modified))
character.DTM_df <- merge(character_table[,c("char", "play", "genre")], character.DTM_df, by.x = "row.names", by.y = "row.names", suffixes = c("", ".DTM"))
```


##PLOT!
First we make our SOM
```{r}

library(kohonen)
character.SOM <- som(as.matrix(character.DTM_df[,!names(character.DTM_df) %in% c("Row.names","char","play","genre")]), 
                     grid = somgrid(10, 10, "hexagonal"), 
                     toroidal = TRUE)
```

Make label matrix
```{r}
characters.to.plot <- c("Romeo", "Juliet", "K. Henry", "Macbeth", "Hermia",
    "Othello", "Puck")

character.labels <- c()

X <- character.DTM_df[,"char"]
for (i in 1:length(X)) {
    if (X[i] %in% characters.to.plot) {
        character.labels[i] <- X[i]
    } else {
        character.labels[i] <- "+"
    }
}
remove(i,X)
```


#Plot characters

set palette
```{r}
#palette.3 <- palette(rainbow(3, s=1, v = .9, start = 0))
palette.3 <- c("darkred","darkorchid4", "royalblue4")
palette.3 <- c("firebrick1","darkolivegreen3", "dodgerblue2")
```

Dim all of the labels that we don't wnat to display the full name for.
```{r}

dim.symbols <- function(x){
  if (nchar(x)<2) {return(0.5)}
  else {return(1)}
}

genre.label.data <- 
  cbind(char = character.DTM_df$char,
        label = character.labels, 
        base_color = palette.3[as.factor(character.DTM_df$genre)],
        transparency = lapply(character.labels,dim.symbols))

genre.label.data <- as.data.frame(genre.label.data)

label.colors <- c()
for (row in 1:nrow(genre.label.data)){
  label.colors[row] <- adjustcolor(genre.label.data[row,"base_color"], alpha.f = genre.label.data[row,"transparency"])
}

genre.label.data <- cbind(genre.label.data, label_color = label.colors)
remove(row, label.colors)
```

##color by genre
```{r}
par(bg = hsv(h=0,s=0,v=.7))
plot(character.SOM, 
     type = "mapping",
     col = as.character(genre.label.data$label_color),
     bgcol = hsv(h=0.8,s=.3,v=(.5*(0.3+code.distances(character.SOM)))),
     labels = genre.label.data$label)
```




```{r}

plot(character.SOM, 
     type = "mapping",
     col = as.character(genre.label.data$label_color),
     bgcol = hsv(h=0,s=0,v=code.distances(character.SOM)),
     labels = genre.label.data$label)
```

