---
title: "Shakespeare SOMs"
author: Daniel Tanner
date: "`r format(Sys.time(), '%d %B, %Y')`"
output:
  html_document:
   toc: True
   toc_depth: 2
   toc_float: True
---
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, tidy = TRUE, fig.align='center', message = FALSE, warning = FALSE)
```

#Downloading Shakespeare Text
The following downloads a zipped folder containing all of the text of 37 of Shakespeare's plays (originally [available at lexically.net](http://lexically.net/wordsmith/support/shakespeare.html)).

```{r}

td <- tempdir() 
tf <- tempfile(tmpdir=td)
#download.file("http://lexically.net/downloads/corpus_linguistics/ShakespearePlaysPlus.zip", tf)

download.file("https://github.com/clarkdatalabs/soms/raw/master/ShakespearePlaysPlus.zip", tf)

#https://github.com/clarkdatalabs/soms/blob/master/ShakespearePlaysPlus.zip?raw=true


fname <- unzip(tf, list=TRUE)$Name[1] 
unzip(tf, exdir=td, overwrite=TRUE) 
fpath <- file.path(td, fname)
remove(fname)
unlink(tf)
```

The next level of subdirectory is the play genre.
```{r}
genres <- list.dirs(fpath, full.names = FALSE, recursive = FALSE)
```

We want to read in all of the play text while saving play names and genres as metadata.

```{r}
library("readr")
play_table <- data.frame(play=character(),
                         genre=character(),
                         text=character())

for (genre in genres){
  plays <- list.files(file.path(fpath,genre), pattern = ".txt")
  for (play in plays){
    text <- read_file(file.path(fpath,genre,play), locale(encoding = "UTF-16"))
    play.name <- gsub('.txt','', play)
    play_table <- rbind(play_table, data.frame(play = play.name, genre = genre, text = text))
  }
}
remove(genre, plays, play, play.name, text)
```


##Clean out bracketed tags

```{r}
play_table$text <- gsub('<[^>]*>','', play_table$text)
```

#Form & Clean Corpus

Form into corpus:
```{r form corpus}
library("tm")

play.vec <- VectorSource(play_table[,"text"])
play.corpus <- Corpus(play.vec)
```

Next we want to really clean up our texts. The tm package has functions for stripping punctuation, numbers, whitespace, the most common words (we don't want to be comparing counts of "and" and "to"), and converting everything to lowercase. We'll also use a function from the `SnowballC` package to cut words down to common stems for comparison.

_Note: this may take a few minutes to run._
```{r clean corpus 1}
library("SnowballC")

play.corpus <- tm_map(play.corpus, removePunctuation)
play.corpus <- tm_map(play.corpus, removeNumbers)
play.corpus <- tm_map(play.corpus, tolower)
play.corpus <- tm_map(play.corpus, removeWords, stopwords("english"))
play.corpus <- tm_map(play.corpus, stemDocument)
play.corpus <- tm_map(play.corpus, stripWhitespace)
play.corpus <- tm_map(play.corpus, PlainTextDocument)
play.corpus <- tm_map(play.corpus, removePunctuation)
```

Let's check out what some of the cleaned text looks like:
```{r inspect cleaned text}
substr(inspect(play.corpus[12]),1,500)
```

The functions that rely on english dictionaries had a bit of trouble with the Shakespearean English, but they're close enough.

##Document Term Matrix
Add in metadata for plotting

```{r make document term matrix}
play.DTM <- DocumentTermMatrix(play.corpus)
```

##Restrict to common words
so matrix not super sparse

```{r}
play.DTM.modified <- removeSparseTerms(play.DTM, 0.8)
```


##Normalize rows
- make each a length 1 vector
-add attributes for plotting
```{r}
play.DTM.modified <- t(apply(play.DTM.modified, 1, function(x) x / sqrt(sum(x^2)) ))
attr(play.DTM.modified, "play") <- play_table$play
attr(play.DTM.modified, "genre") <- play_table$genre

```



#SOM!

```{r}
library(kohonen)

play.SOM <- som(scale(play.DTM.modified), grid = somgrid(6,6, "hexagonal"),  toroidal = FALSE)
plot(play.SOM)
```

```{r}
plot(play.SOM, type = "mapping", col = palette(rainbow(3,v=.9))[as.integer(attr(play.DTM.modified, "genre"))], bgcol = "lightgray", labels = attr(play.DTM.modified, "play"))
```


This is not a particularly clean or useful visualization. There are two main problems that we will address below.
* There are too many labeled points, which become illegible.
* The gray backgrounds of teh cells don't communicate anything. It would be nice if they could be used to convey distance of a cell to it's negihbors, like in the `dist.neighbours` type SOMs.

First, we'll just make a list of the plays we want labeled, and represent the rest with *x*.

```{r}
plays.to.plot <- c("Romeo And Juliet", "Julius Caesar", "King Lear", "Macbeth", "Othello, the Moor of Venice", "The Tragedy of King Richard II", "The Tragedy of King Richard III", "The Tempest", "The Taming of the Shrew")
play.labels <- c()
X <- as.vector(attr(play.DTM.modified, "play"))
for (i in 1:37){
  if (X[i] %in% plays.to.plot){play.labels[i] <- X[i]}
  else{play.labels[i]<-"x"}
}
```

Next, we want to essentially combine two types of kohonen SOM functions, `mapping` and `dist.neighbours`. TO do this we will write our own function to calculate the distance of a cell's representative vector to all others, strongly weighing the neighboring cells. We'll then use this do set the background color using the `mapping` type SOM.

```{r}
code.distances <- function(SOM){
  N <- nrow(SOM$codes)
  #calculate all pairwise distances
  pairwise.distances = c()
  for (i in 1:N){
    list <- matrix()
    for (j in 1:N){
      list[j] <- dist(rbind(SOM$codes[i,],SOM$codes[j,]))
    }
    pairwise.distances <- cbind(pairwise.distances, list)
  }
  
  ##distance coefficient function, to be applied to geometric GRID distances
  d.coef<-function(x){
    if (x == 0){return(0)}
    else{return(1/(x^4))}
    }
  distance.coefficients <- apply(kohonen::unit.distances(SOM$grid, SOM$toroidal),c(1,2),d.coef)
  
  #calculate scaled sum of distances
  A<-distance.coefficients*pairwise.distances
  scaled.dist.sums <- colSums(A)/max(colSums(A))
  
  return(scaled.dist.sums)
}
```

Putting it all together:

```{r}
plot(play.SOM, type = "mapping", col = palette(rainbow(3,v=.9))[as.integer(attr(play.DTM.modified, "genre"))], bgcol = hsv(h=0,s=0,v=code.distances(play.SOM)), labels = play.labels)
```



#Character SOM

```{r, indclude = FALSE, eval = FALSE}
library("RCurl")
character_table <- read.csv(text=getURL("https://raw.githubusercontent.com/clarkdatalabs/soms/master/Shakespeare_txt/character_table.csv"), sep=",", header=T, check.names = FALSE, stringsAsFactors = FALSE)
```

#DELETE Characters with AE in NAME!!!!
FIX THIS LATER!!

```{r}
#character_table <- character_table[-c(238,416,543,654,938,962,988,1089,1323),]
```



##Read in character lines

There are some errors accessing the text files with unicode characters in their names. I'll just throw some error handling around this and drop these characters from consideration.

```{r, indclude = FALSE, eval = FALSE}
library("readr")
for (row in row.names(character_table)){
  tryCatch({
    character_table[row, "text"] <- read_file(as.character(character_table[row,"path"]) , locale(encoding = "UTF-16"))
  }, error=function(e){print(row)})
}
remove(row)
```

```{r}
#character_table <- character_table[!is.na(character_table$text),]
```


###
DOWNLOAD CHAR TABLE
```{r}
library("RCurl")
character_table <- read.csv(text=getURL("https://raw.githubusercontent.com/clarkdatalabs/soms/master/Shakespeare_txt/CHAR.csv"), sep=",", header=T, check.names = FALSE, stringsAsFactors = FALSE)
```




Let's look at the metadata we have for each text file of lines:

```{r}
head(character_table[,c("character", "play", "genre")], 10)
```

Note the [*dramatis_personae*](https://en.wikipedia.org/wiki/Dramatis_person%C3%A6) character. Each play has one of these documents, which is just a list of characters and contains no lines. Let's get rid of them.

```{r}
character_table <- subset(character_table, character!="dramatis_personae")
```

The text here has the same bracketed tags, white space, punctuation, and uncommon words that we stripped out of the play text above, so we follow the same procedure to simplify it.

##Clean out bracketed tags

```{r}
character_table$text <- gsub('<[^>]*>','', character_table$text)
```

#Form & Clean Corpus

Form into corpus:
```{r}
library("tm")
character.corpus <- Corpus(VectorSource(character_table[,"text"]))
```

_Note: this may take a few minutes to run._
```{r clean character corpus}
library("SnowballC")

character.corpus <- tm_map(character.corpus, removePunctuation)
character.corpus <- tm_map(character.corpus, removeNumbers)
character.corpus <- tm_map(character.corpus, tolower)
character.corpus <- tm_map(character.corpus, removeWords, stopwords("english"))
character.corpus <- tm_map(character.corpus, stemDocument)
character.corpus <- tm_map(character.corpus, stripWhitespace)
character.corpus <- tm_map(character.corpus, PlainTextDocument)
character.corpus <- tm_map(character.corpus, removePunctuation)
```



##Doc Term Matrix

```{r}
character.DTM <- DocumentTermMatrix(character.corpus)
```


##TF-IDF - SHOULD I USE THIS INSTEAD OF WEIGHTING?
```{r}
#test.DTM <- DocumentTermMatrix(character.corpus, control = list(weighting = weightTfIdf))
```

##Reduce Sparseness
For the character text mining we want to use a much higher sparse factor. We have far fewer words to work with for each character (compared to entire plays). We don't want to eliminate too many words.

```{r}
character.DTM.modified <- removeSparseTerms(character.DTM, 0.90)

attr(character.DTM, "character") <- character_table$character
attr(character.DTM, "genre") <- character_table$genre
row.names(character.DTM.modified) <- character_table$character
```

Let's see what this did to the wordcounts for some of our characters.
```{r}
wordcount.DTM <- rowSums(as.matrix(character.DTM))
wordcount.DTM.modified <- rowSums(as.matrix(character.DTM.modified))

head(cbind("DTM" = wordcount.DTM,
           "DTM.modified" = wordcount.DTM.modified), 10)
```

Overall this seems to have cut a fair number of words out of each character's wordcount. Also note that there are some characters don't have many lines at all. Let's exclude characters that have fewer than 30 filtered words.

```{r}
character.DTM.modified <- character.DTM.modified[wordcount.DTM.modified>200, ]
```

##Normalize

```{r}
character.DTM.modified <- t(apply(character.DTM.modified, 1, function(x) x/sqrt(sum(x^2))))
```


##PLOT!
First we make our SOM
```{r}
library(kohonen)
character.SOM <- som(scale(character.DTM.modified), grid = somgrid(10, 10, "hexagonal"), toroidal = TRUE)
```

Make label matrix
```{r}


char.info <- character_table[character_table$character %in% attributes(character.DTM.modified)$dimnames$Docs,c("character", "play", "genre")]

library(stringi)
characters.to.plot <- c("Romeo", "Juliet", "K. Henry", "Macbeth", "Hermia",
    "Othello", "Puck")
character.labels <- c()
X <- stri_trans_totitle(attributes(character.DTM.modified)$dimnames$Docs)
for (i in 1:length(X)) {
    if (X[i] %in% characters.to.plot) {
        character.labels[i] <- X[i]
    } else {
        character.labels[i] <- "+"
    }
}

```

#Plot characters
```{r}
plot(character.SOM, type = "mapping", bgcol = hsv(h=0,s=0,v=code.distances(character.SOM)), labels = character.labels)
```




#Clean up Workspace
```{r}
unlink(td, recursive = FALSE)
```
